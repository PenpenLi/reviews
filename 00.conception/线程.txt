
7.应用程序与程序
用户可以在同一时间内运行多个应用程序，每个应用程序被称作一个任务
一个应用程序通常由多个程序program组成，
一个程序就是一个正在执行的进程（程序的概念有时被忽略）
8.进程与线程
进程是系统进行资源分配和调度的基本单元，由程序数据、进程控制块组成。
一个进程可以包含多个多线程，
线程是程序执行流的最小单元，由线程ID，当前指令指针，寄存器集合和对战组成。
9.协程
一个进程可包含多个协程，协程是一种用户态的轻量级线程。即协程是由用户程序自己控制调度的。
线程和进程都是同步机制，而协程是异步机制。
进程和线程是操作系统级的，协程是编译器级的。
10.协程与回调
[[	
	-- 步骤
	协程A开始执行。
	协程A执行到一半，进入暂停，执行权转移到协程B。
	一段时间后，协程B交还执行权。
	协程A恢复执行。
	== 注意
	必须在只有一个单线程里实现并发
	修改共享数据不加锁
	用户程序里自己保存多个控制流的上下文栈
	一个协程遇到IO操作自动切换到其他协程
]]
11.多进程
每个进程都有自己的独立内存空间，不共享。
进程之间的通讯由操作系统传递，导致通讯效率低，切换开销大。
密集CPU任务，需要充分使用多核CPU资源（服务器，大量的并行计算）的时候，用多进程。	
缺点：多个进程之间通信成本高，切换开销大。
12.多线程
同一个进程内所有线程共享进程内存空间，通讯效率高，切换开销小。共享导致数据不安全，引入互斥锁。
密集I/O任务（网络I/O,磁盘I/O,数据库I/O）使用多线程合适。
缺点：同一个时间切片只能运行一个线程，不能做高并行，但可以做高并发。
13.并行
多个处理器或者是多核的处理器同时处理多个不同的任务。 
14.并发
多线程是通过线程轮流切换，来获取CPU执行时间的
15.高并发
通过严谨的设计来保证系统能够，同时并行处理很多请求。

==============================================================================
5.同步与异步
对请求的发起者，是否需要等待请求结果，还是请求完毕后以某种形式同时请求发起者。
6.阻塞与非阻塞
对请求的处理者，在处理某个请求的状态下，是否还能做其他的事情（请求处理时间不确定）
16.进程间通信
管道：速度慢，容量有限，只有福字进程能通讯
FIFO：任何进程间都能通讯，但速度慢
消息队列：容量收到系统限制，且要注意第一次读的时候，要考虑上次没有读完的数据的问题
信号量：不能传递复杂消息，只能用来同步
共享内存区：能够很容易控制容量，速度快，但要保持同步。比如一个进程写时，另一个进程要注意读写，相当于线程中的县城安全。
Socket和Stream：支持不同主机上的两个进程IPC.
17.线程同步
创建  
挂起
终止

22.同步与互斥的区别
互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。
	但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
	在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。
	少数情况是指可以允许多个访问者同时访问资源
23.多线程的同步互斥
信号量 使用互斥锁+条件变量
[[
	https://zhuanlan.zhihu.com/p/55123862
	19.信号量--线程的同步
	是包含一个非负整型变量，并且带有两个原子操作wait和signal。
	wait和可以被称为down、P或lock，signal还可以被称为up、V、unlock或post。
	20.互斥量--线程的互斥
	临界区：必须以互斥方式执行的代码段，也就是说在临界区的范围内只能有一个活动的执行进程。
	互斥锁：一种用来保护临界区的特殊变量。每个互斥锁内部有一个线程等待队列，用来保存等待改互斥锁的线程。
	静态初始化、动态初始化
	加锁解锁、销毁互斥锁
	21.死锁【互斥锁导致问题】
	死锁：两个或两个以上的执行序在执行过程中，因争夺资源而造成的一种互相等待的现象。
	死锁的避免：当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。
	22.条件变量
	静态初始化、动态初始化
	等待：在不满足条件时，将一直等待、将等待一段时间
	通知：可以唤醒条件变量等待队列等待线程中的，一个或者所有。
	23.作用域
	信号量：进程间或线程间
	互斥锁：线程间
]]

==============================================================================
24.实现一个线程池的
https://crossoverjie.top/2018/07/29/java-senior/ThreadPool/


25.Input/Output Completion Port（I/O 完成端口）
iocp:https://blog.csdn.net/jing_nnn/article/details/102635428

26.怎样做线程同步
https://blog.csdn.net/s_lisheng/article/details/74278765
多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，
因此加入同步锁以避免在该线程没有完成操作之前，被其他线程调用，从而保证了该变量的唯一性和准确性。
线程同步:是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。
线程互斥:是指对于共享的操作系统资源，在各线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。
在WIN32中（区别于Linux，其实也差不多），同步机制主要有以下几种：
（1）事件(Event);WaitForSingleObject(hEvent, INFINITE);//等待对象为有信号状态；；；手动设置事件：SetEvent(hEvent); 自动恢复状态：
（2）信号量(semaphore);信号量状态在其计数大于0时是有信号的，而其计数是0时是无信号的。信号量对象在控制上可以支持有限数量共享资源的访问。
		WaitForSingleObject(hSemaphore, INFINITE);//等待信号量为有信号状态; ReleaseSemaphore(hSemaphore, 1, &count);
（3）互斥量(mutex);采用互斥对象机制。只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。
		WaitForSingleObject(hMutex, INFINITE); ReleaseMutex(hMutex);
（4）临界区(Critical section)。一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问.
		EnterCriticalSection(&Critical); LeaveCriticalSection(&Critical);

===================================END===========================================



